<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Yuanhang Zheng]]></title>
  <link href="http://itlodge.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://itlodge.github.io/"/>
  <updated>2013-07-23T23:07:31+08:00</updated>
  <id>http://itlodge.github.io/</id>
  <author>
    <name><![CDATA[Yuanhang Zheng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More consts enums inlines and less #defines]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/23/more-consts-enums-inlines-and-less-defines/"/>
    <updated>2013-07-23T21:33:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/23/more-consts-enums-inlines-and-less-defines</id>
    <content type="html"><![CDATA[<p>This is an old topic.</p>

<h1>For constants</h1>

<p>Consider a macro below.</p>

<pre><code>#define PI 3.14
</code></pre>

<p>There are several drawbacks when using a macro.</p>

<ul>
<li><p>It's hard to debug.As we all know, the macros are resolved by the
preprocessor and the compiler know nothing about them.When you get an error
when compiling the program, the error message may refer to <code>3.14</code> but not
<code>PI</code> because <code>PI</code> is not in the symbol table.</p></li>
<li><p>It will result in more object codes.When the preprocessor replace <code>PI</code>
with <code>3.14</code>, there will be several copy of 3.14 in the object code.</p></li>
</ul>


<p>If we use the <strong>constant</strong> instead of the macro,</p>

<pre><code>const double Pi = 3.14;
</code></pre>

<p>it has the following advantages, respectively.</p>

<ul>
<li><p>It's easy to debug, since the constant is in the symble table.</p></li>
<li><p>It has only one copy in the object code.The other place it appears is just
its references.</p></li>
</ul>


<p>But I think it has disadvantages too.</p>

<p>When replacing lots of <strong>macros</strong> with <strong>constant</strong>, there will be
lots of entries in the symbol table.And it will make the object files or
executable files larger.</p>

<p>When defining a constant string, we may want to do this.</p>

<pre><code>const char *Name = "Tom";
</code></pre>

<p>But this is not effecient.</p>

<p>If defined above, the value "Tom" cannot be changed, but what the pointer
<code>Name</code> points to can be changed.So the compiler will allocate a piece of
memory for the pointer <code>Name</code> in the normal data segment.Moreover, when
the linker starts working, it need to perform some relocations for <code>Name</code>.</p>

<p>So, it's better to be defined as follows.</p>

<pre><code>const char * const Name = "Tom";
</code></pre>

<p>or</p>

<pre><code>const char Name[] = "Tom";
</code></pre>

<p>Now the compiler will put <code>Name</code> in the read only data segment and the linker
needn't performing relocations.</p>

<p>Alternatively, we can use this.</p>

<pre><code>const std::string Name("Tom");
</code></pre>

<h1>For class-specific constants</h1>

<p>Sometimes we need a constant member in the class, for example.</p>

<pre><code>class Hand {
private:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};
</code></pre>

<p>In order to ensure there is only one copy of the constant, it must be
<code>static</code>.</p>

<p>However, <code>static const int NumFingers = 5;</code> is just a <strong>declaration</strong> for
<code>NumFinger</code>.Why this can be compiled with no error message?Everything
should have its definition, does it?However, the class-specific constants
that are static and with integral type(<code>int</code>, <code>char</code>, <code>bool</code>,...) is
an exception.</p>

<p>You can even use the constant.</p>

<pre><code>#include &lt;cstdio&gt;

class Hand {
 public:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};

int main(int argc, char *argv[])
{
    printf("%d\n", Hand::NumFingers);

    return 0;
}
</code></pre>

<p>But when you want to use the address of <code>NumFingers</code>, you must put the
definition of <code>NumFingers</code> in the implemetation file of the class.</p>

<pre><code>#include &lt;cstdio&gt;

class Hand {
 public:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};

const int Hand::NumFingers;

int main(int argc, char *argv[])
{
    printf("%p\n", &amp;Hand::NumFingers);

    return 0;
}
</code></pre>

<p>Remember, there is no need to put <code>static</code> at the begining of the definition.</p>

<p>We know that the size of the array <code>finger</code> is just the value of the static
constant <code>NumFingers</code>.But there is another way to do that.</p>

<pre><code>class Hand {
 public:
    enum {NumFingers = 5};
    int fingers[NumFingers];
};
</code></pre>

<p>That is fine, too.</p>

<h1>For functions</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some reviews about C plus plus]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus/"/>
    <updated>2013-07-22T19:33:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus</id>
    <content type="html"><![CDATA[<h1>Declaration and Definition</h1>

<p>I have already known the difference between <strong>declaration</strong> and <strong>definion</strong>,
but now I find that my understanding is not complete.</p>

<p><strong>Declaration</strong> just tells the compiler about the name and the type of
something.It's very common about the declaration of <em>objects</em> and <em>functions</em>.</p>

<pre><code>extern int a;

int max(int a, int b);
</code></pre>

<p>However, I never think about the declaration of <em>class</em>.Recently, I have to
view some codes in a large project and I have found many of these declarations.</p>

<pre><code>class Option;
class Parameter;
</code></pre>

<p>Additionally, there are many declarations of the <em>template class</em>.</p>

<pre><code>template&lt;typename T&gt;
class Swap;
</code></pre>

<p>Another interesting thing is that the official C++ definition of
<em>function signature</em> excludes the return type.I think this is strange and I
will consider it, anyway.</p>

<p><strong>Definition</strong> gives the details of something to the compiler.In the past, I
hold the opinion that <em>definition</em> always be related to <em>memory</em>.In fact, it is
not allways.
- For object, the definition tell the compiler about the memory asigned for the
object.
- For function or function template, the definition provides the function body.
- For class or class template, the definition lists the members of the class.</p>

<p>For example:</p>

<pre><code>int a;

int max(int a, int b)
{
    return a &gt; b ? a : b;
}

class Option {
public:
    Option();
    ~Option();
    ...
};
</code></pre>

<h1>Defaul constructor</h1>

<p>I found I can't tell whether a constructor is a <strong>default constructor</strong> or not.
But now, I know.A <strong>default constructor</strong> is a constructor that can be called
without any arguments.That is, either no parameters or every parameter is
initialized.</p>

<p>The following are default constructors.</p>

<pre><code>Option();
explicit Option(bool short = true);
</code></pre>

<p>And this one is not a default constructor.</p>

<pre><code>explicit Option(bool short);
</code></pre>

<p>What the hell <strong>explicit</strong> is doing here?I have never used this reserved word
even if I have learned C++ for several years.But this guy, <em>explicit</em>, is of
great importance.</p>

<p>Placing <em>explicit</em> before the constructor can prevent the objects of the class
being used to perform implicit type conversions.Obviously, they can be used
for explicit type conversions.</p>

<p>For example, if we have two classes and a function.</p>

<pre><code>class Dog {
    explicit Dog();
    ...
}

Dog aDog;
Cat aCat;

void kill(Dog d);
</code></pre>

<p>Now call the <code>kill</code> function passing <code>aDog</code> as parameter.</p>

<pre><code>kill(aDog);    // No problem.
</code></pre>

<p>If with the <code>explicit</code> reserved word and call the <code>kill</code> function passing
<code>aCat</code> as parameter, it will be error since it prevents implicit type
conversions.</p>

<pre><code>kill(aCat);    // Error, prevent implicit conversion.
</code></pre>

<p>But if without the <code>explicit</code> reserved word and call the <code>kill</code> function
passing <code>aCat</code> as parameter, it will lead the compiler to perform unexpected
type conversions.So the policy is:</p>

<p><strong>Always declare the constructor as explicit.</strong></p>

<h1>Copy constructor and copy assignment operator</h1>

<p>I have already known that this</p>

<pre><code>Parameter p1;
</code></pre>

<p>will invoke the <em>default constructor</em> and this</p>

<pre><code>Parameter p2(p1);
</code></pre>

<p>will invoke the <em>copy constructor</em> and this</p>

<pre><code>p1 = p2;
</code></pre>

<p>will invoke the <em>copy assignment operator</em>, but I have never known that this</p>

<pre><code>Parameter p3 = p2;
</code></pre>

<p>will not invoke the <em>copy assignment operator</em> but the <em>copy constructor</em>.</p>

<p>This amazes me very much.But now I can distinguish it easily.</p>

<p>If a new object is being defined, invoke the <em>copy constructor</em>.Otherwise,
invoke the <em>copy assignment operator</em> since it's just the <strong>asignment</strong>.</p>

<h1>Some common sense</h1>

<ul>
<li>TR1, Technical Report 1, is a specification for new functionality in
C++ standard library.</li>
</ul>


<p>This really deepens my understanding of C plus plus and now I am very
interested in this great programming language.</p>
]]></content>
  </entry>
  
</feed>
