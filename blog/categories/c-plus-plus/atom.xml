<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Yuanhang]]></title>
  <link href="http://itlodge.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://itlodge.github.io/"/>
  <updated>2013-07-23T20:54:56+08:00</updated>
  <id>http://itlodge.github.io/</id>
  <author>
    <name><![CDATA[Yuanhang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some reviews about C plus plus]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus/"/>
    <updated>2013-07-22T19:33:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus</id>
    <content type="html"><![CDATA[<h1>Declaration and Definition</h1>

<p>I have already known the difference between <strong>declaration</strong> and <strong>definion</strong>,
but now I find that my understanding is not complete.</p>

<p><strong>Declaration</strong> just tells the compiler about the name and the type of
something.It's very common about the declaration of <em>objects</em> and <em>functions</em>.</p>

<pre><code>extern int a;

int max(int a, int b);
</code></pre>

<p>However, I never think about the declaration of <em>class</em>.Recently, I have to
view some codes in a large project and I have found many of these declarations.</p>

<pre><code>class Option;
class Parameter;
</code></pre>

<p>Additionally, there are many declarations of the <em>template class</em>.</p>

<pre><code>template&lt;typename T&gt;
class Swap;
</code></pre>

<p>Another interesting thing is that the official C++ definition of
<em>function signature</em> excludes the return type.I think this is strange and I
will consider it, anyway.</p>

<p><strong>Definition</strong> gives the details of something to the compiler.In the past, I
hold the opinion that <em>definition</em> always be related to <em>memory</em>.In fact, it is
not allways.
- For object, the definition tell the compiler about the memory asigned for the
object.
- For function or function template, the definition provides the function body.
- For class or class template, the definition lists the members of the class.</p>

<p>For example:</p>

<pre><code>int a;

int max(int a, int b)
{
    return a &gt; b ? a : b;
}

class Option {
public:
    Option();
    ~Option();
    ...
};
</code></pre>

<h1>Defaul constructor</h1>

<p>I found I can't tell whether a constructor is a <strong>default constructor</strong> or not.
But now, I know.A <strong>default constructor</strong> is a constructor that can be called
without any arguments.That is, either no parameters or every parameter is
initialized.</p>

<p>The following are default constructors.</p>

<pre><code>Option();
explicit Option(bool short = true);
</code></pre>

<p>And this one is not a default constructor.</p>

<pre><code>explicit Option(bool short);
</code></pre>

<p>What the hell <strong>explicit</strong> is doing here?I have never used this reserved word
even if I have learned C++ for several years.But this guy, <em>explicit</em>, is of
great importance.</p>

<p>Placing <em>explicit</em> before the constructor can prevent the objects of the class
being used to perform implicit type conversions.Obviously, they can be used
for explicit type conversions.</p>

<p>For example, if we have two classes and a function.</p>

<pre><code>class Dog {
    explicit Dog();
    ...
}

Dog aDog;
Cat aCat;

void kill(Dog d);
</code></pre>

<p>Now call the <code>kill</code> function passing <code>aDog</code> as parameter.</p>

<pre><code>kill(aDog);    // No problem.
</code></pre>

<p>If with the <code>explicit</code> reserved word and call the <code>kill</code> function passing
<code>aCat</code> as parameter, it will be error since it prevents implicit type
conversions.</p>

<pre><code>kill(aCat);    // Error, prevent implicit conversion.
</code></pre>

<p>But if without the <code>explicit</code> reserved word and call the <code>kill</code> function
passing <code>aCat</code> as parameter, it will lead the compiler to perform unexpected
type conversions.So the policy is:</p>

<p><strong>Always declare the constructor as explicit.</strong></p>

<h1>Copy constructor and copy assignment operator</h1>

<p>I have already known that this</p>

<pre><code>Parameter p1;
</code></pre>

<p>will invoke the <em>default constructor</em> and this</p>

<pre><code>Parameter p2(p1);
</code></pre>

<p>will invoke the <em>copy constructor</em> and this</p>

<pre><code>p1 = p2;
</code></pre>

<p>will invoke the <em>copy assignment operator</em>, but I have never known that this</p>

<pre><code>Parameter p3 = p2;
</code></pre>

<p>will not invoke the <em>copy assignment operator</em> but the <em>copy constructor</em>.</p>

<p>This amazes me very much.But now I can distinguish it easily.</p>

<p>If a new object is being defined, invoke the <em>copy constructor</em>.Otherwise,
invoke the <em>copy assignment operator</em> since it's just the <strong>asignment</strong>.</p>

<h1>Some common sense</h1>

<ul>
<li>TR1, Technical Report 1, is a specification for new functionality in
C++ standard library.</li>
</ul>


<p>This really deepens my understanding of C plus plus and now I am very
interested in this great programming language.</p>
]]></content>
  </entry>
  
</feed>
