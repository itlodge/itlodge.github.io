<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Yuanhang Zheng]]></title>
  <link href="http://itlodge.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://itlodge.github.io/"/>
  <updated>2013-08-27T22:58:39+08:00</updated>
  <id>http://itlodge.github.io/</id>
  <author>
    <name><![CDATA[Yuanhang Zheng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some interview questions about array and string]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/25/some-interview-questions-about-array-and-string/"/>
    <updated>2013-08-25T08:43:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/25/some-interview-questions-about-array-and-string</id>
    <content type="html"><![CDATA[<h2>Hash Table</h2>

<p>In C++, the namespace<code>std::tr1</code> contains lots of hash tables. We can play
with it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (careerup-hash.cpp)</span> <a href='/code/careerup-hash.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tr1/unordered_map&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">HashMap</span><span class="p">;</span>
</span><span class='line'>    <span class="n">HashMap</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">num</span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">num</span><span class="p">[</span><span class="s">&quot;two&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hash_func</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">hash_function</span><span class="p">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">HashMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span>
</span><span class='line'>                  <span class="o">&lt;&lt;</span> <span class="s">&quot;(hash=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Questions</h2>

<p><strong>1.1.</strong> Implement an algorithm to determine if a string has all unique
characters. What if you can not use additional data structures?</p>

<p>I have come up with 2 methods.</p>

<ul>
<li><p>Iterate the string and compare each character to other character. This is the
common way to solve this problem. It will cost (O ^ 2) time.</p></li>
<li><p>Use the <code>std::tr1::unordered_set</code> data structure so that we can only iterate
the string once.</p></li>
</ul>


<p>Here is the code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (careerup-1.1.cpp)</span> <a href='/code/careerup-1.1.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;tr1/unordered_set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str1</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str2</span> <span class="o">=</span> <span class="s">&quot;abca&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Normal unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Normal not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_set</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Set unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_set</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Set not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">Set</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Set</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>However, there are two more effecient methods.</p>

<ul>
<li><p>If the string contains only ASCII(Ask the interviewer!), we can use an array
of size 256 to mark every character. The time complexity is O(n). But this is
to sacrifice space for time, just as the unordered_set method.</p></li>
<li><p>If the string contains only letters, we can use a 4-bytes integer to mark the
characters in the string.</p></li>
</ul>


<p>Here is the code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (careerup-1.1-answer.cpp)</span> <a href='/code/careerup-1.1-answer.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_array</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str1</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str2</span> <span class="o">=</span> <span class="s">&quot;abca&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_array</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Array unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_array</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Array not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bit unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bit not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_array</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">has_char</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="kc">false</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">has_char</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">has_char</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">char_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">char_flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">char_flag</span> <span class="o">|=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><strong>1.2.</strong> Write code to reverse a C-Style String(C-String means that &ldquo;abcd&rdquo; is
represented as five characters, including the null character)</p>

<p>The approach I come up with is described as follows.</p>

<ol>
<li><p>Get the length of the string, which needs iterate the whole string.</p></li>
<li><p>According to the property of continuing, we can manipulate the string
from the end. So we can swap the first character with the last character,
and swap the second character with the last but not least character, &hellip;
This needs iterate half of the string.</p></li>
</ol>


<p>In sumary, this will need O(1.5n) &ndash;> O(n) time complexity. Here is the code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (careerup-1.2.cpp)</span> <a href='/code/careerup-1.2.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="n">reverse_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reverse_str</span><span class="p">(</span><span class="n">test_str</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="n">reverse_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>However, the answer is using pointer instead of index. But the algorithm and
the time complexity are the same. Here is the code.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (careerup-1.2-answer.cpp)</span> <a href='/code/careerup-1.2-answer.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">reverse</span><span class="p">(</span><span class="n">test_str</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">++</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="o">--</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>            <span class="o">*</span><span class="n">str</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>            <span class="o">*</span><span class="n">end</span><span class="o">--</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This code has several problems. First, the variable <code>end</code> and <code>tmp</code> should
be defined in the <code>if</code> block. Otherwise, if <code>str</code> is <code>NULL</code>, the
definition of the two variables will be wasteful. Second, using the pointer with
the <code>++</code> and <code>--</code> is error-prone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do not hide inherited names]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/15/do-not-hide-inherited-names/"/>
    <updated>2013-08-15T19:26:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/15/do-not-hide-inherited-names</id>
    <content type="html"><![CDATA[<p>In inheritance, there are some rules defined by C++, one of which is that
the virables or the functions in the base class will be hidden if there
are virables and functions with the same name.</p>

<p>It seems perfect, but it&rsquo;s a pitfall of C++. Consider the following example.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;

class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    sleep() const
    { printf("Person sleep\n"); }
    void
    sleep(const int sec) const
    { printf("Person sleep %d s\n", sec); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
};

class Student:public Person {
public:
    explicit Student()
    { }
    ~Person()
    { }
    void
    sleep() const
    { printf("Student sleep\n"); }
private:
    Student(const Student&amp;);
    const Student&amp;
    operator=(const Student&amp;);
};

int
main(int argc, char **argv)
{
    Student stu;

    stu.sleep();
    stu.sleep(1);

    return 0;
}
</code></pre>

<p>This program won&rsquo;t be compiled. It shows the following error:</p>

<pre><code>test.cpp:39:16: error: no matching function for call to ‘Student::sleep(int)’
     stu.sleep(1);
                ^
test.cpp:39:16: note: candidate is:
test.cpp:25:5: note: void Student::sleep() const
     sleep() const
     ^
test.cpp:25:5: note:   candidate expects 0 arguments, 1 provided
</code></pre>

<p>That is because C++ will hide all the names in the base class as long as there
are the same names in the derived class. In the <code>Person</code> class, <code>sleep()</code>
and <code>sleep(const int sec)</code> have the same name. In the <code>Student</code> class, it
only want to override the <code>sleep()</code> function, but the overriding cause the
hiding of the <code>sleep(const int sec)</code> function!</p>

<p>So how to solve this problem? There are two methods so far.</p>

<ol>
<li>Don&rsquo;t hide the names in the base class will using overloading functions.</li>
<li><p>Use <code>using</code> directive to make the certain methods visible.</p>

<pre><code> class Student:public Person {
 public:
     using Person::sleep;

     explicit Student()
     { }
     ~Person()
     { }
     void
     sleep() const
     { printf("Student sleep\n"); }
</code></pre></li>
</ol>


<p>Finally, another important thing should be stated. In the above example, I
implement <code>sleep()</code> function in the definition of the class. Why do that?
I have worked in some very large C++ projects and there are many implementation
in the definition. In fact, this is so-called <strong>implicit inline</strong>. The compiler
will inline the functions that are implemented in the class definition
automatically. Therefore, it&rsquo;s good to implement some small functions in the
definition of class. And let the large function implement in another file.
This will make my code more effecient and I will follow this guide in the
future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postponing definitions instead of preponing]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/11/postponing-definitions-instead-of-preponing/"/>
    <updated>2013-08-11T11:26:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/11/postponing-definitions-instead-of-preponing</id>
    <content type="html"><![CDATA[<h2>Prepone definitions? Wrong!</h2>

<p>Before C99, you must prepone all the variables' definitions before any
statements. But after C99 was released, you can put a variable&rsquo;s definition
in any place as long as before being used. I think this new feature is
introduced by learning from C++.</p>

<p>This makes programer write codes more convenient. But I used to insist the
old style. I even teach my students that they should use the old style when
I was a TA of the course <em>Programming with C</em>.</p>

<p>However, now I realize that I was wrong. <strong>We should postpone variables'</strong>
<strong>definitions as long as possible</strong>. It&rsquo;s not for coding style, but for the
effeciency of the program.</p>

<p>Consider this program.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;

void
save_pwd(const std::string&amp; pwd)
{
    std::string salted_pwd("abc");

    if (pwd.size() &lt; 6) {
        fprintf(stderr, "Password too short.");
        return;
    }
    salted_pwd += pwd;
    ...
}

int
main(int argc, char **argv)
{
    save_pwd("ddd");

    return 0;
}
</code></pre>

<p>When running this program, it will print an error and exit the function.
The variable <code>salted_pwd</code> is not used. So, defining <code>salted_pwd</code> above
the <code>if</code> statement will waste the memory, the time to allocate memory and
the time to free memory. For the view of C++, you will pay for the cost of
construction and destruction of the object <code>salted_pwd</code>.</p>

<h2>Define and then assign? Wrong!</h2>

<p>When I first learned programming in C, my teacher says that</p>

<pre><code>int a;
a = 1;
</code></pre>

<p>is the same as</p>

<pre><code>int a = 1;
</code></pre>

<p>Now I realize that they are not the same and the latter is more effecient.</p>

<p>For the former, <code>int a;</code> will allocate memory for the variable <code>a</code> and
then fill zero bytes in the memory. Then <code>a = 1;</code> will write value <code>1</code>
in the memory.
For the latter, <code>int a = 1;</code> will directly allocate memory for the variable
<code>a</code> and then write value <code>1</code> in the memory.
In other words, you will pay more cost when using the former style.</p>

<p>It seems that it makes little difference with the built-in type. When the
type of the variable <code>a</code> is user-defined type, great difference appears.</p>

<p>For example,</p>

<pre><code>std::string str;
...
std::string = "abc";
</code></pre>

<p>This will first call the default constructor of <code>std::string</code> and then call
the copy assignment operator. So the time and memory used in the default
constructor is wasted.</p>

<p>If we define an object in this way</p>

<pre><code>std::string str("abc");
</code></pre>

<p>or</p>

<pre><code>std::string str = "abc";
</code></pre>

<p>, it will only call the copy constructor. This is more effecient.</p>

<p>So now I prefer this way</p>

<pre><code>for (int i = 0; i &lt; n; i++) {
    ...
}
</code></pre>

<p>instead of</p>

<pre><code>int i;

for (i = 0; i &lt; n; i++) {
    ...
}
</code></pre>

<p>Now there is a special case that is worth thinking.</p>

<pre><code>Person p;
for (int i = 0; i &lt; n; i++) {
    p = persons[i];
    ...
}
</code></pre>

<p>and</p>

<pre><code>for (int i = 0; i &lt; n; i++) {
    Person p = persons[i];
    ...
}
</code></pre>

<p>, which is better?</p>

<p>Let&rsquo;s analysis the performance of them.
* The former need 1 construction, n assignments and 1 destruction. But it makes
the object <code>p</code> in a larger scope, which increase the comprehensibility and
maintainability of the program.
* The latter need n constructions and n destructions.</p>

<p>Which is more effecient? I think it all depends. If assignment is less expensive
than the total of construction and destruction, we should use the former style.
On the contray, we should use the latter style.</p>

<p>The author of <strong>Effective C++</strong> prefers the latter, but I prefer the former,
since I am sensitive with performance and I think memory allocation and free
will be more expensive than assignment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Encapsulation]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/09/understanding-encapsulation/"/>
    <updated>2013-08-09T21:38:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/09/understanding-encapsulation</id>
    <content type="html"><![CDATA[<p>Once I loved <em>C</em> very much and I thought it&rsquo;s the best programming language
in the world. I used to argue that <em>C</em> can be used to implement the
object-oriented design with <code>struct</code>. I used to argue that <code>private</code> and
<code>public</code> is useless in <em>C++</em>. However, now I know I was wrong.</p>

<h2>Why we need private</h2>

<p>It&rsquo;s related to a very important concept in C++, that is, <strong>encapsulation</strong>.</p>

<p><strong>Encapsulation is not invisibility. It&rsquo;s maintainability.</strong></p>

<p>Suppose a class is very popular and is used by many projects. For example,
the <code>string</code> class. If every members in this class is <code>public</code>, the clients
can use many interfaces to manipulate <code>string</code>. One day, when the <code>string</code>
class is going to be modified(some members' name change), then lots of clients
have to modify there code. This is painful! If we declare some of the members
<code>private</code> and change the name of the private members, only the implementations
in the public member functions should be modified. None of the clients need to
change their codes.</p>

<p>Therefore, <strong>public means unchangable and public means unencapsulated</strong>.</p>

<p>The public member functions should not be changed in the future. Since you don&rsquo;t
know how your clients will use your class, don&rsquo;t expose the members that may be
changed in the future to the clients.</p>

<h2>Prefer non-member non-friend functions to member functions</h2>

<p>Consider the following class.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};
</code></pre>

<p>Somebody may want to use the functions together, so we add another member
function.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
    void
    say() const
    {
        say_age();
        say_name();
    }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};
</code></pre>

<p>This is straightforward, especially for those Java and C# programmers. Every
functions should be in a class and everything is object. It&rsquo;s obvious, right?</p>

<p>However, e have another option, that is, using the non-member function.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};

void
person_say(const Person&amp; p)
{
    p.say_age();
    p.say_name();
}
</code></pre>

<p>Which is better? It seems that they are the same.</p>

<p>We should use the non-member function instead of the member function.</p>

<p>As we all know, <strong>the less the public member functions and the friend </strong>
 <strong>functions, the greater encapsulation is</strong>, since member functions and
friend functions are the only interface that can access the private members.</p>

<p>In this example, if we add another public member function, we decrease the
encapsulation of the class since this member function can access the private
members of the class. But if we use the non-member non-friend function, it
won&rsquo;t have impact with the class because it&rsquo;s the function outside.</p>

<p>Does it explain that <em>C++</em> is not so object-oriented? From Java or C#, those
programmers will say that everything is object and classes are everywhere.
However, they are wrong. Object-oriented princiles state that <strong>data should be</strong>
<strong>encapsulated as possible</strong>. Therefore, prefering non-member non-friend
functions is more <em>object-oriented</em>.</p>

<p>Until now, I can say that I really understand the meaning of encapsulation and
why it&rsquo;s so important in object-oriented programming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Always pass parameters by reference-to-const]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/09/always-pass-parameters-by-reference-to-const/"/>
    <updated>2013-08-09T03:42:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/09/always-pass-parameters-by-reference-to-const</id>
    <content type="html"><![CDATA[<p>We all know that <em>pass by value</em> is not effecient.So we use <em>pass by pointer</em>
in C.However, in C++, we prefer <strong>pass by referece-to-const</strong>.</p>

<p>Here is an example.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

class Dog {
public:
    Dog()
    {
        printf("Calling Dog's constructor\n");
    }
    Dog(const Dog&amp; d)
    {
        printf("Calling Dog's copy constructor\n");
        this-&gt;name = d.name;
    }
    virtual ~Dog()
    {
        printf("Calling Dog's destructor\n");
    }
private:
    std::string name;
};

void
walk_the_dog(Dog d)
{

}

int
main(int argc, char **argv)
{
    Dog dog;
    walk_the_dog(dog);

    return 0;
}
</code></pre>

<p>The running result is as follows:</p>

<pre><code>Calling Dog's constructor
Calling Dog's copy constructor
Calling Dog's destructor
Calling Dog's destructor
</code></pre>

<p>Now, let&rsquo;s analysis this <em>passing by value</em> process.
First, <code>Dog dog;</code> will call the constructor. Then, since the function
<code>walk_the_dog</code> pass the parameter <code>d</code> by value, it will call the copy
constructor. Before exiting the function, it will call the destructor of <code>Dog</code>
to destroy the parameter <code>d</code>. In the end, before exiting the main function,
the destructor of <code>Dog</code> will be called again to destroy the <code>dog</code> object.</p>

<p>Now, it seems that <em>passing by value</em> will result in a call to copy constructor
and a call to destructor. But, in fact, it will result in two call to copy
constructor and two call to destructor. Note that there are a <code>string</code> object
as the member of the class <code>Dog</code>, so there will be an extra call the copy
constructor and destructor of the <code>string</code> object.</p>

<p>Obviously, the cost of <em>passing by value</em> is very expensive.
How is <em>passing by reference-to-const</em>?</p>

<pre><code>void
walk_the_dog(const Dog&amp; d)
{

}
</code></pre>

<p>Just modify a bit and the result will be:</p>

<pre><code>Calling Dog's constructor
Calling Dog's destructor
</code></pre>

<p>Note that the <code>const</code> is very important. If there is not a <code>const</code>, the
compiler will put the object in the writable part of the memory so that it
cannot be shared by other functions. If declared as <code>const</code>, the object
will be put into the readonly part of the memory and can be shared by lots
of functions so that the program need less memory.</p>

<p>The implementation of reference is using the pointer in C. Therefore, it may
be more effecient to pass the built-in type parameters by value than referece.
It&rsquo;s true. If the parameter is an object of type <code>char</code>, which occupies
1 byte. But a pointer ocuppies 4 bytes in a 32-bit machine. So we should prefer
passing by value when the parameter is of built-in type? No, we should always
pass the parameters by reference-to-const, since <strong>the compiler will always</strong>
<strong>put the pointer in the register!</strong></p>

<p>Finally, just remember, <strong>always pass the parameters by reference-to-const</strong>.</p>
]]></content>
  </entry>
  
</feed>
