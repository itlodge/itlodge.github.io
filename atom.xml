<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Yuanhang Zheng]]></title>
  <link href="http://itlodge.github.io/atom.xml" rel="self"/>
  <link href="http://itlodge.github.io/"/>
  <updated>2013-08-28T19:35:37+08:00</updated>
  <id>http://itlodge.github.io/</id>
  <author>
    <name><![CDATA[Yuanhang Zheng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Some interview questions about array and string]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/25/some-interview-questions-about-array-and-string/"/>
    <updated>2013-08-25T08:43:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/25/some-interview-questions-about-array-and-string</id>
    <content type="html"><![CDATA[<h2>Hash Table</h2>

<p>In C++, the namespace<code>std::tr1</code> contains lots of hash tables. We can play
with it.</p>

<figure class='code'><figcaption><span> (careerup-hash.cpp)</span> <a href='http://itlodge.github.io/code/careerup-hash.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;tr1/unordered_map&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">HashMap</span><span class="p">;</span>
</span><span class='line'>    <span class="n">HashMap</span> <span class="n">num</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">num</span><span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">num</span><span class="p">[</span><span class="s">&quot;two&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">hash_func</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">hash_function</span><span class="p">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">HashMap</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">second</span>
</span><span class='line'>                  <span class="o">&lt;&lt;</span> <span class="s">&quot;(hash=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Questions</h2>

<p><strong>1.1.</strong> Implement an algorithm to determine if a string has all unique
characters. What if you can not use additional data structures?</p>

<p>I have come up with 2 methods.</p>

<ul>
<li><p>Iterate the string and compare each character to other character. This is the
common way to solve this problem. It will cost (O ^ 2) time.</p></li>
<li><p>Use the <code>std::tr1::unordered_set</code> data structure so that we can only iterate
the string once.</p></li>
</ul>


<p>Here is the code.</p>

<figure class='code'><figcaption><span> (careerup-1.1.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.1.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;tr1/unordered_set&gt;</span>
</span><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str1</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str2</span> <span class="o">=</span> <span class="s">&quot;abca&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Normal unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Normal not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_set</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Set unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_set</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Set not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_normal</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_set</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">tr1</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">Set</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Set</span> <span class="n">set</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, there are two more effecient methods.</p>

<ul>
<li><p>If the string contains only ASCII(Ask the interviewer!), we can use an array
of size 256 to mark every character. The time complexity is O(n). But this is
to sacrifice space for time, just as the unordered_set method.</p></li>
<li><p>If the string contains only letters, we can use a 4-bytes integer to mark the
characters in the string.</p></li>
</ul>


<p>Here is the code.</p>

<figure class='code'><figcaption><span> (careerup-1.1-answer.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.1-answer.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_array</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str1</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">test_str2</span> <span class="o">=</span> <span class="s">&quot;abca&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_array</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Array unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_array</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Array not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="n">test_str1</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bit unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="n">test_str2</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bit not unique&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_array</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">has_char</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="kc">false</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">has_char</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">has_char</span><span class="p">[</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">bool</span>
</span><span class='line'><span class="n">has_unique_char_bit</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">char_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">char_flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">char_flag</span> <span class="o">|=</span> <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>1.2.</strong> Write code to reverse a C-Style String(C-String means that &ldquo;abcd&rdquo; is
represented as five characters, including the null character)</p>

<p>The approach I come up with is described as follows.</p>

<ol>
<li><p>Get the length of the string, which needs iterate the whole string.</p></li>
<li><p>According to the property of continuing, we can manipulate the string
from the end. So we can swap the first character with the last character,
and swap the second character with the last but not least character, &hellip;
This needs iterate half of the string.</p></li>
</ol>


<p>In sumary, this will need O(1.5n) &ndash;> O(n) time complexity. Here is the code.</p>

<figure class='code'><figcaption><span> (careerup-1.2.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.2.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="n">reverse_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">reverse_str</span><span class="p">(</span><span class="n">test_str</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span>
</span><span class='line'><span class="n">reverse_str</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">len</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="n">str</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>However, the answer is using pointer instead of index. But the algorithm and
the time complexity are the same. Here is the code.</p>

<figure class='code'><figcaption><span> (careerup-1.2-answer.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.2-answer.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">reverse</span><span class="p">(</span><span class="n">test_str</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">reverse</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="o">++</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="o">--</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">str</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>
</span><span class='line'>            <span class="o">*</span><span class="n">str</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
</span><span class='line'>            <span class="o">*</span><span class="n">end</span><span class="o">--</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This code has several problems. First, the variable <code>end</code> and <code>tmp</code> should
be defined in the <code>if</code> block. Otherwise, if <code>str</code> is <code>NULL</code>, the
definition of the two variables will be wasteful. Second, using the pointer with
the <code>++</code> and <code>--</code> is error-prone.</p>

<p><strong>1.3</strong> Design an algorithm and write code to remove the duplicate characters
in a string without using any additional buffer. NOTE: One or two additional
variables are fine. An extra copy of the array is not.</p>

<p>FOLLOW UP</p>

<p>Write the test cases for this method.</p>

<p>I am not so smart that I can only come up with the straightforward method. Just
iterate the whole string and check from the former characters to find duplicate
character. If there is duplicate, remove it by moving the rest characters front.
Here is the code.</p>

<figure class='code'><figcaption><span> (careerup-1.3.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.3.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstring&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class='line'><span class="cp">#include &lt;ctime&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">rm_dup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">test_str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">rm_dup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">break</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">str</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">i</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>The algorithm is ok but the program is too slow. In fact, the last <code>for</code> loop
is not necessary. Here is the improved version according to the answer.</p>

<figure class='code'><figcaption><span> (careerup-1.3-answer.cpp)</span> <a href='http://itlodge.github.io/code/careerup-1.3-answer.cpp'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstring&gt;</span>
</span><span class='line'><span class="cp">#include &lt;cstdlib&gt;</span>
</span><span class='line'><span class="cp">#include &lt;ctime&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">rm_dup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str1</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abcd&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str1</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str2</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;aaaa&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str3</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str3</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str4</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;aaabbb&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str4</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str5</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;abababa&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str5</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="n">test_str6</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
</span><span class='line'>    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">test_str6</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">rm_dup</span><span class="p">(</span><span class="n">test_str6</span><span class="p">);</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">test_str6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span>
</span><span class='line'><span class="n">rm_dup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">tail</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">break</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">tail</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">str</span><span class="p">[</span><span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="n">tail</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">str</span><span class="p">[</span><span class="n">tail</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do not hide inherited names]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/15/do-not-hide-inherited-names/"/>
    <updated>2013-08-15T19:26:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/15/do-not-hide-inherited-names</id>
    <content type="html"><![CDATA[<p>In inheritance, there are some rules defined by C++, one of which is that
the virables or the functions in the base class will be hidden if there
are virables and functions with the same name.</p>

<p>It seems perfect, but it&rsquo;s a pitfall of C++. Consider the following example.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;

class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    sleep() const
    { printf("Person sleep\n"); }
    void
    sleep(const int sec) const
    { printf("Person sleep %d s\n", sec); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
};

class Student:public Person {
public:
    explicit Student()
    { }
    ~Person()
    { }
    void
    sleep() const
    { printf("Student sleep\n"); }
private:
    Student(const Student&amp;);
    const Student&amp;
    operator=(const Student&amp;);
};

int
main(int argc, char **argv)
{
    Student stu;

    stu.sleep();
    stu.sleep(1);

    return 0;
}
</code></pre>

<p>This program won&rsquo;t be compiled. It shows the following error:</p>

<pre><code>test.cpp:39:16: error: no matching function for call to ‘Student::sleep(int)’
     stu.sleep(1);
                ^
test.cpp:39:16: note: candidate is:
test.cpp:25:5: note: void Student::sleep() const
     sleep() const
     ^
test.cpp:25:5: note:   candidate expects 0 arguments, 1 provided
</code></pre>

<p>That is because C++ will hide all the names in the base class as long as there
are the same names in the derived class. In the <code>Person</code> class, <code>sleep()</code>
and <code>sleep(const int sec)</code> have the same name. In the <code>Student</code> class, it
only want to override the <code>sleep()</code> function, but the overriding cause the
hiding of the <code>sleep(const int sec)</code> function!</p>

<p>So how to solve this problem? There are two methods so far.</p>

<ol>
<li>Don&rsquo;t hide the names in the base class will using overloading functions.</li>
<li><p>Use <code>using</code> directive to make the certain methods visible.</p>

<pre><code> class Student:public Person {
 public:
     using Person::sleep;

     explicit Student()
     { }
     ~Person()
     { }
     void
     sleep() const
     { printf("Student sleep\n"); }
</code></pre></li>
</ol>


<p>Finally, another important thing should be stated. In the above example, I
implement <code>sleep()</code> function in the definition of the class. Why do that?
I have worked in some very large C++ projects and there are many implementation
in the definition. In fact, this is so-called <strong>implicit inline</strong>. The compiler
will inline the functions that are implemented in the class definition
automatically. Therefore, it&rsquo;s good to implement some small functions in the
definition of class. And let the large function implement in another file.
This will make my code more effecient and I will follow this guide in the
future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postponing definitions instead of preponing]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/11/postponing-definitions-instead-of-preponing/"/>
    <updated>2013-08-11T11:26:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/11/postponing-definitions-instead-of-preponing</id>
    <content type="html"><![CDATA[<h2>Prepone definitions? Wrong!</h2>

<p>Before C99, you must prepone all the variables&#8217; definitions before any
statements. But after C99 was released, you can put a variable&rsquo;s definition
in any place as long as before being used. I think this new feature is
introduced by learning from C++.</p>

<p>This makes programer write codes more convenient. But I used to insist the
old style. I even teach my students that they should use the old style when
I was a TA of the course <em>Programming with C</em>.</p>

<p>However, now I realize that I was wrong. <strong>We should postpone variables&#8217;</strong>
<strong>definitions as long as possible</strong>. It&rsquo;s not for coding style, but for the
effeciency of the program.</p>

<p>Consider this program.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;iostream&gt;

void
save_pwd(const std::string&amp; pwd)
{
    std::string salted_pwd("abc");

    if (pwd.size() &lt; 6) {
        fprintf(stderr, "Password too short.");
        return;
    }
    salted_pwd += pwd;
    ...
}

int
main(int argc, char **argv)
{
    save_pwd("ddd");

    return 0;
}
</code></pre>

<p>When running this program, it will print an error and exit the function.
The variable <code>salted_pwd</code> is not used. So, defining <code>salted_pwd</code> above
the <code>if</code> statement will waste the memory, the time to allocate memory and
the time to free memory. For the view of C++, you will pay for the cost of
construction and destruction of the object <code>salted_pwd</code>.</p>

<h2>Define and then assign? Wrong!</h2>

<p>When I first learned programming in C, my teacher says that</p>

<pre><code>int a;
a = 1;
</code></pre>

<p>is the same as</p>

<pre><code>int a = 1;
</code></pre>

<p>Now I realize that they are not the same and the latter is more effecient.</p>

<p>For the former, <code>int a;</code> will allocate memory for the variable <code>a</code> and
then fill zero bytes in the memory. Then <code>a = 1;</code> will write value <code>1</code>
in the memory.
For the latter, <code>int a = 1;</code> will directly allocate memory for the variable
<code>a</code> and then write value <code>1</code> in the memory.
In other words, you will pay more cost when using the former style.</p>

<p>It seems that it makes little difference with the built-in type. When the
type of the variable <code>a</code> is user-defined type, great difference appears.</p>

<p>For example,</p>

<pre><code>std::string str;
...
std::string = "abc";
</code></pre>

<p>This will first call the default constructor of <code>std::string</code> and then call
the copy assignment operator. So the time and memory used in the default
constructor is wasted.</p>

<p>If we define an object in this way</p>

<pre><code>std::string str("abc");
</code></pre>

<p>or</p>

<pre><code>std::string str = "abc";
</code></pre>

<p>, it will only call the copy constructor. This is more effecient.</p>

<p>So now I prefer this way</p>

<pre><code>for (int i = 0; i &lt; n; i++) {
    ...
}
</code></pre>

<p>instead of</p>

<pre><code>int i;

for (i = 0; i &lt; n; i++) {
    ...
}
</code></pre>

<p>Now there is a special case that is worth thinking.</p>

<pre><code>Person p;
for (int i = 0; i &lt; n; i++) {
    p = persons[i];
    ...
}
</code></pre>

<p>and</p>

<pre><code>for (int i = 0; i &lt; n; i++) {
    Person p = persons[i];
    ...
}
</code></pre>

<p>, which is better?</p>

<p>Let&rsquo;s analysis the performance of them.
* The former need 1 construction, n assignments and 1 destruction. But it makes
the object <code>p</code> in a larger scope, which increase the comprehensibility and
maintainability of the program.
* The latter need n constructions and n destructions.</p>

<p>Which is more effecient? I think it all depends. If assignment is less expensive
than the total of construction and destruction, we should use the former style.
On the contray, we should use the latter style.</p>

<p>The author of <strong>Effective C++</strong> prefers the latter, but I prefer the former,
since I am sensitive with performance and I think memory allocation and free
will be more expensive than assignment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Encapsulation]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/09/understanding-encapsulation/"/>
    <updated>2013-08-09T21:38:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/09/understanding-encapsulation</id>
    <content type="html"><![CDATA[<p>Once I loved <em>C</em> very much and I thought it&rsquo;s the best programming language
in the world. I used to argue that <em>C</em> can be used to implement the
object-oriented design with <code>struct</code>. I used to argue that <code>private</code> and
<code>public</code> is useless in <em>C++</em>. However, now I know I was wrong.</p>

<h2>Why we need private</h2>

<p>It&rsquo;s related to a very important concept in C++, that is, <strong>encapsulation</strong>.</p>

<p><strong>Encapsulation is not invisibility. It&rsquo;s maintainability.</strong></p>

<p>Suppose a class is very popular and is used by many projects. For example,
the <code>string</code> class. If every members in this class is <code>public</code>, the clients
can use many interfaces to manipulate <code>string</code>. One day, when the <code>string</code>
class is going to be modified(some members&#8217; name change), then lots of clients
have to modify there code. This is painful! If we declare some of the members
<code>private</code> and change the name of the private members, only the implementations
in the public member functions should be modified. None of the clients need to
change their codes.</p>

<p>Therefore, <strong>public means unchangable and public means unencapsulated</strong>.</p>

<p>The public member functions should not be changed in the future. Since you don&rsquo;t
know how your clients will use your class, don&rsquo;t expose the members that may be
changed in the future to the clients.</p>

<h2>Prefer non-member non-friend functions to member functions</h2>

<p>Consider the following class.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};
</code></pre>

<p>Somebody may want to use the functions together, so we add another member
function.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
    void
    say() const
    {
        say_age();
        say_name();
    }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};
</code></pre>

<p>This is straightforward, especially for those Java and C# programmers. Every
functions should be in a class and everything is object. It&rsquo;s obvious, right?</p>

<p>However, e have another option, that is, using the non-member function.</p>

<pre><code>class Person {
public:
    explicit Person()
    { }
    ~Person()
    { }
    void
    say_age() const
    { printf("%d\n", age); }
    void
    say_name() const
    { printf("%s\n", name.c_str()); }
private:
    Person(const Person&amp;);
    const Person&amp;
    operator=(const Person&amp;);
    int age;
    std::string name;
};

void
person_say(const Person&amp; p)
{
    p.say_age();
    p.say_name();
}
</code></pre>

<p>Which is better? It seems that they are the same.</p>

<p>We should use the non-member function instead of the member function.</p>

<p>As we all know, <strong>the less the public member functions and the friend </strong>
 <strong>functions, the greater encapsulation is</strong>, since member functions and
friend functions are the only interface that can access the private members.</p>

<p>In this example, if we add another public member function, we decrease the
encapsulation of the class since this member function can access the private
members of the class. But if we use the non-member non-friend function, it
won&rsquo;t have impact with the class because it&rsquo;s the function outside.</p>

<p>Does it explain that <em>C++</em> is not so object-oriented? From Java or C#, those
programmers will say that everything is object and classes are everywhere.
However, they are wrong. Object-oriented princiles state that <strong>data should be</strong>
<strong>encapsulated as possible</strong>. Therefore, prefering non-member non-friend
functions is more <em>object-oriented</em>.</p>

<p>Until now, I can say that I really understand the meaning of encapsulation and
why it&rsquo;s so important in object-oriented programming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Always pass parameters by reference-to-const]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/09/always-pass-parameters-by-reference-to-const/"/>
    <updated>2013-08-09T03:42:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/09/always-pass-parameters-by-reference-to-const</id>
    <content type="html"><![CDATA[<p>We all know that <em>pass by value</em> is not effecient.So we use <em>pass by pointer</em>
in C.However, in C++, we prefer <strong>pass by referece-to-const</strong>.</p>

<p>Here is an example.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

class Dog {
public:
    Dog()
    {
        printf("Calling Dog's constructor\n");
    }
    Dog(const Dog&amp; d)
    {
        printf("Calling Dog's copy constructor\n");
        this-&gt;name = d.name;
    }
    virtual ~Dog()
    {
        printf("Calling Dog's destructor\n");
    }
private:
    std::string name;
};

void
walk_the_dog(Dog d)
{

}

int
main(int argc, char **argv)
{
    Dog dog;
    walk_the_dog(dog);

    return 0;
}
</code></pre>

<p>The running result is as follows:</p>

<pre><code>Calling Dog's constructor
Calling Dog's copy constructor
Calling Dog's destructor
Calling Dog's destructor
</code></pre>

<p>Now, let&rsquo;s analysis this <em>passing by value</em> process.
First, <code>Dog dog;</code> will call the constructor. Then, since the function
<code>walk_the_dog</code> pass the parameter <code>d</code> by value, it will call the copy
constructor. Before exiting the function, it will call the destructor of <code>Dog</code>
to destroy the parameter <code>d</code>. In the end, before exiting the main function,
the destructor of <code>Dog</code> will be called again to destroy the <code>dog</code> object.</p>

<p>Now, it seems that <em>passing by value</em> will result in a call to copy constructor
and a call to destructor. But, in fact, it will result in two call to copy
constructor and two call to destructor. Note that there are a <code>string</code> object
as the member of the class <code>Dog</code>, so there will be an extra call the copy
constructor and destructor of the <code>string</code> object.</p>

<p>Obviously, the cost of <em>passing by value</em> is very expensive.
How is <em>passing by reference-to-const</em>?</p>

<pre><code>void
walk_the_dog(const Dog&amp; d)
{

}
</code></pre>

<p>Just modify a bit and the result will be:</p>

<pre><code>Calling Dog's constructor
Calling Dog's destructor
</code></pre>

<p>Note that the <code>const</code> is very important. If there is not a <code>const</code>, the
compiler will put the object in the writable part of the memory so that it
cannot be shared by other functions. If declared as <code>const</code>, the object
will be put into the readonly part of the memory and can be shared by lots
of functions so that the program need less memory.</p>

<p>The implementation of reference is using the pointer in C. Therefore, it may
be more effecient to pass the built-in type parameters by value than referece.
It&rsquo;s true. If the parameter is an object of type <code>char</code>, which occupies
1 byte. But a pointer ocuppies 4 bytes in a 32-bit machine. So we should prefer
passing by value when the parameter is of built-in type? No, we should always
pass the parameters by reference-to-const, since <strong>the compiler will always</strong>
<strong>put the pointer in the register!</strong></p>

<p>Finally, just remember, <strong>always pass the parameters by reference-to-const</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A tour to The Badaling Great Wall]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/03/a-tour-to-the-badaling-great-wall/"/>
    <updated>2013-08-03T19:52:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/03/a-tour-to-the-badaling-great-wall</id>
    <content type="html"><![CDATA[<p>Today, I went to the Badaling Great Wall <strong>alone</strong>.</p>

<p>There is a saying that <strong>He who has never been to the Great Wall is not a</strong>
<strong>true man</strong>.</p>

<p>I had read this saying for many times when I was in high school, but I have
never been to the Great Wall util today.</p>

<p>I got up at 7:00am and began my tour at about 7:40am after the breakfast.
It took me 30 minutes to arrive at <em>Xi zhi men station</em> from where I live.</p>

<p><img class="right" src="http://itlodge.github.io/pictures/13.8.3.Great-Wall-too-many-people.jpg" width="300" height="350" title="'Too many people'" ></p>

<p>I planed to take the <em>Shi jiao yan qing s2 line</em> train to the Great Wall
directly at <em>Beijing bei station</em>, which is near the <em>Xi zhi men station</em>.
However, when I arrived there, the staff of the station said that the train
will depart at 11:00am.I watched my smart phone, which showed that it&rsquo;s
8:24am now.So I had to wait for about 2.5 hours if I took this train.Because
I&#8217;am those one who don&rsquo;t want to stay in a place too long and want to go
somewhere to have a look, I prefer the other type of a tour.Therefore, from
the staff of the train, I knew that I could take buses to the Great Wall.</p>

<p>Thanks to the <em>Baidu Map</em>, this time I need to take the <em>line 13 train</em> and
arrive at the <em>Long ze station</em>, then take the <em>878 bus</em>.However, when I
arrived at the <em>Long ze station</em> and the <em>878 bus station</em>, I found something
almost shock me.That is, the <em>878 bus</em> only depart at 7:00am-9:00am.But my
smart phone showed that it&rsquo;s 9:03am.Oh my god!But I didn&rsquo;t give up.I stayed
there for another 20 minutes.This time, I almost wanted to go back home because
I looked for 10 minutes to find some bus that can go to the Great Wall and I
failed.</p>

<p><img class="left" src="http://itlodge.github.io/pictures/13.8.3.south-wall.jpg" width="300" height="350" title="'South Wall'" ></p>

<p>I was still stubborn so that I found another way to go to the Great Wall from
<em>Baidu Map</em>.This time I went back to the <em>Xi er qi station</em>, take the
<em>Chang ping line train</em> and arrived at the final station <em>Nan shao station</em>.
When I got out of the station, I was shock again.This place is a remote village
and I can&rsquo;t find a bus after looking for 10 minutes.So I went back to the
exit of the subway and ask a driver of the <em>black car</em> how much of taking me
to the Badaling Great Wall.His answer suprised me because he wanted 180 yuan.
Although I could bargin with him to reduce the price to 100 yuan, but it&rsquo;s
still very very very expensive.This time I wanted to give up and went away to
find another bus station.When I got there, I found it&rsquo;s excactly the bus I
could take to the Great Wall.This is the <em>870 bus</em> and then the bus didn&rsquo;t
appear.Fortunately, the bus was coming soon and I got in without thinking.
That is, <strong>there is a way out for somebody</strong>.</p>

<p>After about an hour, I arrived at <em>Ni sha he station</em> and I need to change to
another bus.This time, I could take <em>919 bus</em> or the <em>879</em> bus and I felt the
Great Wall was near.After about 5 minutes, the bus comed but there were too
many people there, so I had to stand in the bus.I thought the bus will arrived
at the Great Wall no more than 20 minutes, but I never wanted to know that it&rsquo;s
the most painful bus I have ever taken.I standed in the bus for more than 1.5
hours because of the traffic jam!</p>

<p>Finally I arrived at the Great Wall.</p>

<p>First, I have a lunch at <em>Yong he da wang restaurant</em>.</p>

<p><img src="http://itlodge.github.io/pictures/13.8.3.have-a-lunch.jpg" title="Have a lunch" alt="Have a lunch"></p>

<p>There were lots of people.But I thought there will be more in Spring and Autumn.
The photo below shows the <em>North Wall</em>.</p>

<p><img src="http://itlodge.github.io/pictures/13.8.3.north-wall.jpg" title="North Wall" alt="North Wall"></p>

<p>It&rsquo;s obvious that I was on the south wall, and the photo below is a bird&rsquo;s-eye
view of the north wall.</p>

<p><img src="http://itlodge.github.io/pictures/13.8.3.north-wall-bird-view.jpg" title="North Wall bird view" alt="North Wall bird view"></p>

<p>There is no doubt that I must have someone take a photo for myself.The photo
below is it, I&rsquo;m not very handsome as you imaged, though.</p>

<p><img src="http://itlodge.github.io/pictures/13.8.3.Great-Wall-me.jpg" title="Me" alt="Me"></p>

<p>The return tour was so relax because I could take the <em>877 bus</em> to
<em>De sheng men xi station</em> directly!And it const me only 4.8 yuan.</p>

<p>In a word, although <em>the Badaling Great Wall</em> is not so <strong>great</strong> as
<em>the Palace</em>, I was still very happy today, because it&rsquo;s the first time I have
a tour <strong>alone</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cpp Resource Management]]></title>
    <link href="http://itlodge.github.io/blog/2013/08/01/cpp-resource-management/"/>
    <updated>2013-08-01T22:16:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/08/01/cpp-resource-management</id>
    <content type="html"><![CDATA[<p>I always forget freeing a memory that allocated from the heap.And I always
forget closing the file handler.</p>

<p>Resources include file descriptors, mutex locks, fonts, brushes, database
connections and network sockets.</p>

<p>I think less programmers can remember closing a file handler, especially
in a large project.</p>

<p>Nowadays, many programming languages have the garbage collection function.
In C++, since the destructor will be automatically called, we can release
the resources automatically if we put the resource into an object.</p>

<p>How can do that?Use the <em>smart pointer</em>:<code>std::auto_ptr</code>.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::auto_ptr&lt;int&gt; ap(num);
    }
    // delete num;

    return 0;
}
</code></pre>

<p>If trying to delete num after the block, that will be a double free error.</p>

<p>Reference from <a href="http://www.cplusplus.com/reference/memory/auto_ptr/">cplusplus.com</a>, <code>auto_ptr</code> is deprecated in C++11 and is replaced by <code>unique_ptr</code>.
But they are similar.</p>

<p>However, multiple <code>auto_ptr</code> cannot contain the same object.</p>

<p>Here is the test program.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::auto_ptr&lt;int&gt; ap1(num);
        std::auto_ptr&lt;int&gt; ap2(ap1);

        printf("%p\n", &amp;ap1);
        ap1 = ap2;
        printf("%p\n", &amp;ap2);
    }
    // delete num;

    return 0;
}
</code></pre>

<p>And here is the gdb debug output information.</p>

<pre><code>Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe6e8) at test.cpp:7
7       int *num = NULL;
(gdb) n
9       num = new int();
(gdb) n
10      std::auto_ptr&lt;int&gt; ap1(num);
(gdb) n
11      std::auto_ptr&lt;int&gt; ap2(ap1);
(gdb) p ap1
$1 = {_M_ptr = 0x601010}
(gdb) p ap2
$2 = {_M_ptr = 0x7fff00000001}
(gdb) n
13      printf("%p\n", &amp;ap1);
(gdb) p ap1
$3 = {_M_ptr = 0x0}
(gdb) p ap2
$4 = {_M_ptr = 0x601010}
(gdb) n
0x7fffffffe5e0
14      ap1 = ap2;
(gdb) p ap1
$5 = {_M_ptr = 0x0}
(gdb) p ap2
$6 = {_M_ptr = 0x601010}
(gdb) n
15      printf("%p\n", &amp;ap2);
(gdb) p ap1
$7 = {_M_ptr = 0x601010}
(gdb) p ap2
$8 = {_M_ptr = 0x0}
(gdb) 
</code></pre>

<p>But there are another smart pointer that can do this.It&rsquo;s the
<code>std::tr1::shared_ptr</code>.Mutiple shared_ptr can contain the same object.</p>

<p>The testing program is as follow.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;tr1/memory&gt;

int
main(int argc, char **argv)
{
    int *num = NULL;
    {
        num = new int();
        std::tr1::shared_ptr&lt;int&gt; ap1(num);
        std::tr1::shared_ptr&lt;int&gt; ap2(ap1);

        printf("%p\n", &amp;ap1);
        ap1 = ap2;
        printf("%p\n", &amp;ap2);
    }

    return 0;
}
</code></pre>

<p>And the gdb debug information is:</p>

<pre><code>Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe6e8) at test.cpp:7
7       int *num = NULL;
(gdb) n
9       num = new int();
(gdb) n
10      std::tr1::shared_ptr&lt;int&gt; ap1(num);
(gdb) n
11      std::tr1::shared_ptr&lt;int&gt; ap2(ap1);
(gdb) n
13      printf("%p\n", &amp;ap1);
(gdb) p ap1
$1 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) p ap2
$2 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) n
0x7fffffffe5d0
14      ap1 = ap2;
(gdb) n
15      printf("%p\n", &amp;ap2);
(gdb) p ap1
$3 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
(gdb) p ap2
$4 = std::tr1::shared_ptr (count 2, weak 0) 0x602010
</code></pre>

<p>We can see that both of <code>ap1</code> and <code>ap2</code> point to the same object.</p>

<p>The <code>auto_ptr</code> and <code>shared_ptr</code> use <code>delete</code> but not <code>delete[]</code>,
so they don&rsquo;t support array.But the <code>unique_ptr</code> support.</p>

<p>Sometimes, the resource may be a mutex, and we don&rsquo;t want to remember
unlocking the mutex every time we lock it.So a resource management object
may be:</p>

<pre><code>#include &lt;cstdio&gt;

typedef int Mutex;

void
lock(Mutex *p)
{
    printf("Locking...\n");
}

void
unlock(Mutex *p)
{
    printf("Unlocked\n");
}

class Lock {
public:
    explicit Lock(Mutex *p)
        :pMutex(p)
    {
        lock(pMutex);
    }
    ~Lock()
    {
        unlock(pMutex);
    }
private:
    Mutex *pMutex;
};

int
main(int argc, char **argv)
{
    Mutex m;
    {
        Lock ml(&amp;m);
    }

    return 0;
}
</code></pre>

<p>However, when we copy the <code>Lock</code> object, problems appear.</p>

<pre><code>Lock ml2(ml);
</code></pre>

<p>The default copy constructor will directly copy the pointer <code>pMutex</code> to
the target object.So we should let the object uncopyable.</p>

<pre><code>private:
Lock(const Lock&amp;);
Lock&amp;
operator=(const Lock&amp;);

Mutex *pMutex;
</code></pre>

<p>Multiple objects can use the same resource, so the resource may be existed
until the last object has been destroyed.The <code>tr1::shared_ptr</code> provide a
<code>deleter</code> and its <strong>shared ability</strong> to solve this problem.</p>

<pre><code>class Lock {
public:
    explicit Lock(Mutex *p)
        :pMutex(p, unlock)
    {
        lock(pMutex.get());
    }
private:
    Lock(const Lock&amp;);
    Lock&amp;
    operator=(const Lock&amp;);

    std::tr1::shared_ptr&lt;Mutex&gt; pMutex;
};
</code></pre>

<h2>Provide access to raw resources</h2>

<p>Sometimes we may only want to access the raw resource but the object that
contains the resource.For example:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;tr1/memory&gt;

typedef int Mutex;

static Mutex *
createMutex()
{
    static Mutex *p = new Mutex();

    return p;
}

int
main(int argc, char **argv)
{
    std::tr1::shared_ptr&lt;Mutex&gt; pMutex;

    printf("%d\n", pMutex);

    return 0;
}
</code></pre>

<p>Therefore, we must provide a method to access the raw resource.Like this.</p>

<pre><code>    printf("%d\n", pMutex.get());
</code></pre>

<p>There are two ways, one is explicit and the other is implicit.</p>

<pre><code>class MutexManager {
public:
    explicit MutexManager(Mutex* p)
        :p_(p)
    { }
    ~MutexManager()
    {
        delete p_;
    }
    Mutex
    get() const
    {
        return *p_;
    }
private:
    Mutex *p_;
};

int
main(int argc, char **argv)
{
    MutexManager mm(createMutex());

    printf("%d\n", mm.get());

    return 0;
}
</code></pre>

<p>This one above is exciplit conversion.And this one below is implicit.</p>

<pre><code>class MutexManager {
public:
    explicit MutexManager(Mutex* p)
        :p_(p)
    { }
    ~MutexManager()
    {
        delete p_;
    }
    operator Mutex() const
    {
        return *p_;
    }
private:
    Mutex *p_;
};

void
print(Mutex m)
{
    printf("%d\n", m);
}

int
main(int argc, char **argv)
{
    MutexManager mm(createMutex());

    print(mm);

    return 0;
}
</code></pre>

<p>It&rsquo;s obviously that the explicit method is safer and the implicit method is
more convenient for clients.</p>

<h2>Keep new and delete in the same form</h2>

<p>We all know that the following code is wrong.</p>

<pre><code>std::string *str = new std::string[10];
delete str;
</code></pre>

<p>We should use <code>delete []str;</code> instead of <code>delete str;</code>.</p>

<p>But how about this?</p>

<pre><code>#include &lt;iostream&gt;

typedef std::string Lines[4];

int
main(int argc, char **argv)
{
    std::string *p = new Lines;
    delete p;

    return 0;
}
</code></pre>

<p>If let me delete the pointer p, I will use this <code>delete p;</code>.But I am wrong.
I shouldn&rsquo;t look at the left of the pointer, that is, <code>std::string</code>.I should
look at the right of the <code>new</code>, that is, <code>Lines</code>.So, in this case, we
should use <code>delete []p;</code>.</p>

<p>Avoid typedef for array types, use <code>vector</code> instead.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About Constructors Destructors and Assignment Operators]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/28/about-constructors-destructors-and-assignment-operators/"/>
    <updated>2013-07-28T18:32:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/28/about-constructors-destructors-and-assignment-operators</id>
    <content type="html"><![CDATA[<h2>What functions C++ will silently write and call?</h2>

<p>If we declare an empty class, the compiler will declare a constructor,
a copy constructor, a copy assignment operator and a destructor for us.</p>

<pre><code>class Girl {

};
</code></pre>

<p>But the compiler is not foolish, it will only generate them when needed.</p>

<p>What do the generated functions do?</p>

<ul>
<li><p>For construtor, it will invoke the corresponding constructor and non-static
members of its base class.</p></li>
<li><p>For destructor, it will invoke the corresponding destructor of its base class.
If its base class&rsquo;s destructor is virtual, the destructor will declare as
virtual.</p></li>
<li><p>For copy constructor and copy assignment operator, they will copy each
non-static data member from the source object to the target object.</p></li>
</ul>


<p>If the class has some members that are pointer, reference or constant, there
will be some trouble with the compiler.Therefore, always define the four
functions when we define our own class.</p>

<h2>Disallow the use of generated functions you don&rsquo;t want</h2>

<p>Sometimes, we may not want the copy constructor or the copy assignment
operator because every member may be different with the other object&rsquo;s
members.Preventing the generation of these functions will make the
program more effecient.</p>

<p>If we don&rsquo;t declare these two functions, the compiler will generate them
for us.</p>

<p>So how can we do?</p>

<p>The prefer solution is <strong>declare the copy constructor and copy assignment</strong>
<strong>operator as private and never implement them</strong>.</p>

<p>If we implement them, the members and friends of the class can call them.But
if we don&rsquo;t implement them, the linker will complain at it.</p>

<p>In order to move the link-time error to the compile time, we should let the
members and the friends of the class cannot call them.One method is to define
a base class that can&rsquo;t be copied and inherited by the class that you don&rsquo;t
want it to be copyable.</p>

<pre><code>class Uncopyable {
protected:
    Uncopyable()
    { }
    ~Uncopyable()
    { }
private:
    Uncopyable(const Uncopyable&amp;);
    Uncopyable&amp; operator=(const Uncopyable&amp;);
};

class Person: private Uncopyable {

};
</code></pre>

<p>The copy constructor and copy assignment operator of the class <code>Uncopyable</code>
are declared as private, so the members and friends of class <code>Person</code> can&rsquo;t
call them.</p>

<h2>Declare destructors virtual in polymorphic base classes</h2>

<p>I have met this problem in an interview.</p>

<p>Suppose the destructor of the base class is not virtual.</p>

<pre><code>class Dog {
public:
    Dog();
    ~Dog();
};
</code></pre>

<p>And there are two class inherited from it.</p>

<pre><code>class Whippet:public Dog {

};

class Spaniel:public Dog {

};
</code></pre>

<p>We can use a base class pointer to handle the derived classes.</p>

<pre><code>Dog *aDog = new Whippet();
...
</code></pre>

<p>Then you should delete the pointer when you want to quit.</p>

<pre><code>delete aDog;
</code></pre>

<p>Now, the problem appears.The C++ specifies that when a derived class
object is deleted through a pointer to a base class with a non-virtual
destructor, results are undefined.</p>

<p>That is, the destructor of the base class will be called typically, but
the destructor of the derived class may not be called.</p>

<p>I have written a simple program to test it.</p>

<pre><code>#include &lt;cstdio&gt;

class Dog {
public:
    Dog()
    { }
    ~Dog()
    {
        printf("Call Dog's destructor\n");
    }
private:
    Dog(const Dog&amp;);
    Dog&amp;
    operator=(const Dog&amp;);
};

class Whippet:public Dog {
public:
    Whippet()
    { }
    ~Whippet()
    {
        printf("Call Whippet's destructor\n");
    }
};

int
main(int argc, char **argv)
{
    Dog *aDog = new Whippet();
    delete aDog;

    return 0;
}
</code></pre>

<p>I run the program several times and the results are the same.</p>

<pre><code>~/test $ ./test 
Call Dog's destructor
</code></pre>

<p>Now, if I change the destrutor to <code>virtual</code>, the result is:</p>

<pre><code>virtual ~Dog()
{
    printf("Call Dog's destructor\n");
}

~/test $ ./test 
Call Whippet's destructor
Call Dog's destructor
</code></pre>

<p>Therefore, when the base class have virtual member functions, you should
always make the destructor virtual.</p>

<p>However, not every destructor of any class should be virtual.Making it
virtual will occupy some additional information(virtual table pointer)
that can increase the size of an object of that class.</p>

<p><strong>Prevent exceptions from leaving destructors</strong></p>

<p><strong>Never call virtual functions during construction or destruction</strong></p>

<p>I have seen the assignment operator in this form many times.</p>

<pre><code>Person&amp; operator=(const Person&amp; p)
{
    ...
    return *this;
}
</code></pre>

<p>First, the parameter is passed by const-reference, which is more effecient.
Second, the function returns a reference of the object.This is more effecient
when doing this.</p>

<pre><code>p3 = p2 = p1;
</code></pre>

<p>Remember that always write assignment operator in this form.</p>

<p>This is also appropriate with <code>+=</code>, <code>*=</code> and so on.</p>

<p>Sometimes we may assignment to the object itself.</p>

<pre><code>Person p;
p = p;
</code></pre>

<p>It seems impossible, but how about this.</p>

<pre><code>persons[i] = persons[j];
*p1 = *p2;
</code></pre>

<p><code>persons[i]</code> and <code>persons[j]</code> may be the same.<code>p1</code> and <code>p2</code> may point
to the same object.</p>

<p>Some assignment operator may be like this one.</p>

<pre><code>Disk&amp;
Disk::operator=(const Disk&amp; d)
{
    delete data;
    data = new Disk(*(d.data));

    return *this;
}
</code></pre>

<p>It seems reasonable that delete the original data and then allocate a
new one using the data of <code>d</code>.</p>

<p>However, this is very dangerous.What if <code>this</code> is the same as <code>d</code>?
If that happened, the content of <code>data</code> and <code>d.data</code> is the same
thing.So the content of <code>d.data</code> have been delete before call the
copy constructor.</p>

<p>A direct solution to this problem is obvious.That is, just check if they
are the same.</p>

<pre><code>Disk&amp;
Disk::operator=(const Disk&amp; d)
{
    if (this == &amp;d) {
        return *this;
    }
    delete data;
    data = new Disk(*(d.data));

    return *this;
}
</code></pre>

<p>I prefer the above solution.But there are another solution.</p>

<pre><code>Disk&amp;
Disk::operator=(const Disk&amp; d)
{
    Disk *origin = data;
    data = new Disk(*(d.data));
    delete origin;

    return *this;
}
</code></pre>

<p>This code just change the order of some statement, but it make great
difference.</p>

<p><strong>When adding a member to a class, remember to update the constructors,</strong>
<strong>destructor, copy constructor, copy assignment operator</strong>.</p>

<p><strong>Don&rsquo;t miss anyone!</strong></p>

<p>When a class is a derived class, make sure to call the constructors,
copy constructor and copy assignment operator of the base class, respectively
when writing my own constructors, copy constructor, assignment operator.</p>

<p><strong>Do not call copy constructor in the copy assignment operator.</strong>
<strong>Do not call copy assignment operator in the copy constructor.</strong></p>

<p>That is all about constructors, copy constructor and copy assignment operator.
It really helps.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initialized before used]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/26/initialized-before-used/"/>
    <updated>2013-07-26T22:29:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/26/initialized-before-used</id>
    <content type="html"><![CDATA[<h2>For constructor</h2>

<p>In the constructor, the statements in the body are assignments, not
initializations.</p>

<pre><code>#include &lt;iostream&gt;

class Girl {
public:
    Girl(std::string name, int age)
    {
        name_ = name;    // These are assignments, not initilizations.
        age_ = age;
    }
private:
    std::string name_;
    int age_;
};
</code></pre>

<p>If you do this, the program will be very slow.When calling the constructor,
the program will call the <strong>default construtors</strong> to initialize the members,
and then enter the body of the constructor.Therefor, all the work performed
in the default constructors were wasted.</p>

<p>Using the initilization list instead of the assignment will be more efficient.</p>

<pre><code>#include &lt;iostream&gt;

class Girl {
public:
    Girl(std::string name, int age)
        :name_(name), age_(age)
    { }
private:
    std::string name_;
    int age_;
};
</code></pre>

<p>If the member is <strong>const</strong> or <strong>reference</strong>, you must use initialization list.</p>

<h2>For non-local static objects defined in different translation units</h2>

<p>How long the title was!</p>

<p><strong>static objects</strong> include <em>global objects</em>, <em>objects defined at namespace</em>,
<em>objects defined static inside classes</em>, <em>objects defined static inside
functions</em> and <em>objects declared static at file scope</em>.</p>

<p><em>objects defined static inside functions</em> are called <strong>non-local static objects</strong>.</p>

<p>A <strong>translation unit</strong> is a single source file plus all of its <code>#include</code>files.</p>

<p>Given an example.</p>

<p>main.h:</p>

<pre><code>#ifndef _MAIN_H_
#define _MAIN_H_

class Girl {
public:
    Girl(std::string name, int age)
        :name_(name), age_(age)
    { }
    std::string
    get_name() const
    {
        return "Mary";
    }
private:
    std::string name_;
    int age_;
};

#endif /* _MAIN_H_ */
</code></pre>

<p>main.c:</p>

<pre><code>#include &lt;iostream&gt;
#include "main.h"

extern Girl wife;

class Man {
public:
    Man(std::string name, std::string wife_name)
        :name_(name), wife_name_()
    {
        wife_name_ = wife.get_name();
    }
private:
    std::string name_;
    std::string wife_name_;
};

int
main(int argc, char **argv)
{
    Man m("Tom", "");

    return 0;
}
</code></pre>

<p><code>wife</code> is a non-local static object.In the constructor of class <code>Man</code>,
<code>wife</code> will be used before it is initialized since <strong>the relative order</strong>
<strong>of initialization of non-local static objects defined in different </strong>
<strong>translation units is undefined</strong>.</p>

<p>To let <code>wife</code> be initialized before used, change it to <strong>local static</strong>.</p>

<p>main.h:</p>

<pre><code>#ifndef _MAIN_H_
#define _MAIN_H_

class Girl {
public:
    Girl()
    { }

    Girl(std::string name, int age)
        :name_(name), age_(age)
    { }

    std::string
    get_name() const
    {
        return "Mary";
    }
private:
    std::string name_;
    int age_;
};

#endif /* _MAIN_H_ */
</code></pre>

<p>main.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include "main.h"

class Man {
public:
    Man(std::string name, std::string wife_name)
        :name_(name), wife_name_()
    {
        wife_name_ = wife().get_name();
    }
    Girl&amp;
    wife()
    {
        static Girl w;

        return w;
    }
private:
    std::string name_;
    std::string wife_name_;
};

int
main(int argc, char **argv)
{
    Man m("Tom", "");

    return 0;
}
</code></pre>

<p>The so-call <em>Factory pattern</em> is just like the above code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some basic Ruby]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/25/some-basic-ruby/"/>
    <updated>2013-07-25T20:07:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/25/some-basic-ruby</id>
    <content type="html"><![CDATA[<h2>String and name</h2>

<p>When defining a function, the parentheses are not necessary.So this one</p>

<pre><code>def say_hello name
  "Hello " + name
end

puts say_hello "man"
</code></pre>

<p>is the same as this.</p>

<pre><code>def say_hello(name)
  "Hello " + name
end

puts(say_hello("man"))
</code></pre>

<p>However, when there are more than one parameters, it will be difficult to
know which argument goes with which method invocation.So it&rsquo;s recommended
using parentheses in all but the simplest cases.</p>

<p>We can use single-quote or double-quote to create a string.What&rsquo;s the
difference?</p>

<p>First, single-quoted string can&rsquo;t represent the escape character, and
double-quoted string can.</p>

<pre><code>puts '\nabc'
puts "\nabc"
</code></pre>

<p>The above code will output this.</p>

<pre><code>\nabc

abc
</code></pre>

<p>Second, double-quoted string can be expression interpolated.</p>

<pre><code>name = 'Tom'

puts 'Hello #{name}'
puts "Hello #{name}"
</code></pre>

<p>The above code will output this.</p>

<pre><code>ruby test.rb
Hello #{name}
Hello Tom
</code></pre>

<p>And we can even invoke methods.</p>

<pre><code>name = 'Tom'
puts "Hello #{name.upcase}"
</code></pre>

<p>This will generate the following.</p>

<pre><code>Hello TOM
</code></pre>

<p>When the expression is a global, instance or class variable, there is no need
to use the braces.</p>

<pre><code>@h = "Hello"    # @ means instance
$name = 'Tom'    # $ means global

puts "#@h #$name"
</code></pre>

<p>This will generate the same output.</p>

<p>There are some conventions for the <strong>name</strong> in Ruby.</p>

<ul>
<li><p>Local variables, method parameters and method names <em>should</em> all start
with a lowercase letter or an underscore.</p></li>
<li><p>Class names, module names and constants <em>must</em> start with an uppercase
letter.</p></li>
<li><p>Global variables start with <code>$</code>.</p></li>
<li><p>Instance variables begin with <code>@</code>.</p></li>
<li><p>Class variables are prefixed with <code>@@</code>.</p></li>
</ul>


<h2>Arrays and Hashes</h2>

<p>In ruby, arrays and hashes can hold objects of different types.</p>

<pre><code>a = [1, 'abc', :sym]
puts a
</code></pre>

<p>It will generate the following output.</p>

<pre><code>1
abc
sym
</code></pre>

<p>By the way, <code>nil</code> is an object, represent <strong>nothing</strong>.</p>

<p>If we want to create an array of string, we have to list all the strings.
And we have to type lots of quotes and commas.However, <code>%w</code> can do it
more easily.</p>

<pre><code>a = ['a', 'b', 'c']
b = %w{a b c}

puts a
puts b
</code></pre>

<p>It will generate the following output.</p>

<pre><code>a
b
c
a
b
c
</code></pre>

<p>The index of Array is integer, but the index of Hash is anything.</p>

<p>It has the following form.</p>

<pre><code>var = {
  key1 =&gt; value1
  key2 =&gt; value2
  ...
}
</code></pre>

<p>For example:</p>

<pre><code>girl = {
  :name =&gt; 'Mary',
  :age =&gt; 20
}

puts "#{girl[:name]} is #{girl[:age]} years old."
</code></pre>

<p>Output:</p>

<pre><code>Mary is 20 years old.
</code></pre>

<p>A new Hash can also be created in this way.</p>

<pre><code>decimal = Hash.new(0)
puts decimal[:first]
decimal[:first] = 1
puts decimal[:first]
</code></pre>

<p>Ouput:</p>

<pre><code>0
1
</code></pre>

<p><code>0</code> is the default value for all keys.</p>

<h2>Control Structures</h2>

<p>In Ruby, there is a <code>elsif</code> keyword instead of <code>else if</code>.</p>

<p>The method <code>gets</code> return the next line from the standard input stream and
return nil when get the <code>EOF</code>, so the following code can let all the inputs
be upcase.</p>

<pre><code>while line = gets
  puts line.upcase
end
</code></pre>

<p>If the <code>if</code> and <code>while</code> statement is just a single expression, we usually
write them in this way.</p>

<pre><code>puts 'Hey' if 2 &gt; 1

i = 1
puts i while (i += 1) &lt; 10
</code></pre>

<p>Someone say that this style is similar with <code>Perl</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Const anyway!]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/24/const-anyway/"/>
    <updated>2013-07-24T20:01:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/24/const-anyway</id>
    <content type="html"><![CDATA[<h2>Const pointer</h2>

<p><code>const</code> is versatile.I am always confused by the following syntax.</p>

<pre><code>const char *str = "Hello";    // const data, non-const pointer
char * const str = "Hello";    // const pointer, non-const data
</code></pre>

<p>Now there is a tip to remember it.</p>

<p>If <code>const</code> appears to the right of the asterisk, the pointer is
constant.If <code>const</code> appears to the left of the asterisk, the data
is constant.</p>

<p>So the following two statements are the same.</p>

<pre><code>const char *str = "Hello";
char const *str = "Hello";
</code></pre>

<p>In STL, <code>iterator</code> is just like a <code>T *</code> pointer.
* <code>const std::vector&lt;int&gt;::iterator iter</code> is just like <code>T * const iter</code>.
* <code>std::vector&lt;int&gt;::const_iterator cIter</code> is just like <code>const T *iter</code>.</p>

<p>So, in a loop, if we don&rsquo;t want to modify the data, use <code>const_iterator</code>.</p>

<h2>Const member function</h2>

<p>Sometimes, we have two version member functions.One is const and the other is
not.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

class Str {
public:
    Str(std::string str)
    :data(str)
    { }

    const char&amp;
    operator[](std::size_t pos) const    // Const objects use this
    {
        return data[pos];
    }

    char&amp;
    operator[](std::size_t pos)    // Non-const objects use this
    {
        return data[pos];
    }

private:
    std::string data;
};

void
print(const Str&amp; const_str)
{
    std::cout &lt;&lt; const_str[1] &lt;&lt; std::endl;
}

int
main(int argc, char **argv)
{
    Str nonconst_str("abc");
    std::cout &lt;&lt; nonconst_str[1] &lt;&lt; std::endl;
    nonconst_str[1] = 'a';

    print(nonconst_str);

    return 0;
}
</code></pre>

<p>In <code>main</code>, <code>nonconst_str</code> is a non-const object and it can be modified
by <code>[]</code>.In <code>print</code>, <code>const Str&amp; const_str</code> means
<strong>pass parameters by reference-to-const</strong>, so <code>const_str</code> is a const object.</p>

<p>We observe that the <code>const</code> keyword is after the closing parenthesis of the
argument list.This means the function is a const member function.</p>

<p>Reference to <a href="http://msdn.microsoft.com/en-us/library/6ke686zh.aspx">MSDN</a>,
<strong>A constant member function cannot modify any non-static members or call any</strong>
<strong>member functions that aren&rsquo;t constant.</strong>That is, the cons member function
can&rsquo;t modify the object that it is called.</p>

<p>The above philosophy is called <strong>bitwise constness</strong> or <strong>physical constness</strong>.
There are another philosophy called <strong>logical constness</strong>.Adherents to this
philosophy argue that <strong>a const member function might modify some of the bits</strong>
<strong>in the object on which it&rsquo;s invoked, but only in ways that clients cannot</strong>
<strong>detect</strong>.</p>

<p>For example, if we add a new member function <code>length()</code> to the above class.</p>

<pre><code>    std::size_t
    length() const
    {
        len = data.length();

        return len;
    }

private:
    std::string data;
    std::size_t len;
</code></pre>

<p>This will generate the following compiled error.</p>

<pre><code>test.cpp:25:6: error: assignment of member ‘Str::len’ in read-only object
  len = data.length();
      ^
</code></pre>

<p>Since member variable <code>len</code> has been modified and the compiler use the
<strong>bitwise const</strong>, error produces.However, return and object&rsquo;s length seems
not modify the object it is called.</p>

<p>To solved this problem, use the <strong>mutable</strong> keyword.It can free non-static
data members from bitwise constness constraints.</p>

<pre><code>mutable std::size_t len;
</code></pre>

<p>I beleive in code reusing forever!In the above example, the duplicate code
in the two <code>operator[]</code> functions can be merged into one.</p>

<p>Only then non-const function should be modified.</p>

<pre><code>char&amp;
operator[](std::size_t pos)    // Non-const objects use this
{
    return const_cast&lt;char&amp;&gt;(static_cast&lt;const Str&amp;&gt;(*this)[pos]);
}
</code></pre>

<p><code>static_cast&lt;const Str&amp;&gt;</code>will make <code>*this</code>const and then it can call
<code>operator[]</code>.Finally, <code>const_cast</code> is used the free the const constraint.</p>

<p>This is all about <code>const</code>, it&rsquo;s an amazing keyword.For readable and efficient
code, use it anyway.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More consts enums inlines and less #defines]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/23/more-consts-enums-inlines-and-less-defines/"/>
    <updated>2013-07-23T21:33:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/23/more-consts-enums-inlines-and-less-defines</id>
    <content type="html"><![CDATA[<p>This is an old topic.</p>

<h1>For constants</h1>

<p>Consider a macro below.</p>

<pre><code>#define PI 3.14
</code></pre>

<p>There are several drawbacks when using a macro.</p>

<ul>
<li><p>It&rsquo;s hard to debug.As we all know, the macros are resolved by the
preprocessor and the compiler know nothing about them.When you get an error
when compiling the program, the error message may refer to <code>3.14</code> but not
<code>PI</code> because <code>PI</code> is not in the symbol table.</p></li>
<li><p>It will result in more object codes.When the preprocessor replace <code>PI</code>
with <code>3.14</code>, there will be several copy of 3.14 in the object code.</p></li>
</ul>


<p>If we use the <strong>constant</strong> instead of the macro,</p>

<pre><code>const double Pi = 3.14;
</code></pre>

<p>it has the following advantages, respectively.</p>

<ul>
<li><p>It&rsquo;s easy to debug, since the constant is in the symble table.</p></li>
<li><p>It has only one copy in the object code.The other place it appears is just
its references.</p></li>
</ul>


<p>But I think it has disadvantages too.</p>

<p>When replacing lots of <strong>macros</strong> with <strong>constant</strong>, there will be
lots of entries in the symbol table.And it will make the object files or
executable files larger.</p>

<p>When defining a constant string, we may want to do this.</p>

<pre><code>const char *Name = "Tom";
</code></pre>

<p>But this is not effecient.</p>

<p>If defined above, the value &ldquo;Tom&rdquo; cannot be changed, but what the pointer
<code>Name</code> points to can be changed.So the compiler will allocate a piece of
memory for the pointer <code>Name</code> in the normal data segment.Moreover, when
the linker starts working, it need to perform some relocations for <code>Name</code>.</p>

<p>So, it&rsquo;s better to be defined as follows.</p>

<pre><code>const char * const Name = "Tom";
</code></pre>

<p>or</p>

<pre><code>const char Name[] = "Tom";
</code></pre>

<p>Now the compiler will put <code>Name</code> in the read only data segment and the linker
needn&rsquo;t performing relocations.</p>

<p>Alternatively, we can use this.</p>

<pre><code>const std::string Name("Tom");
</code></pre>

<h1>For class-specific constants</h1>

<p>Sometimes we need a constant member in the class, for example.</p>

<pre><code>class Hand {
private:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};
</code></pre>

<p>In order to ensure there is only one copy of the constant, it must be
<code>static</code>.</p>

<p>However, <code>static const int NumFingers = 5;</code> is just a <strong>declaration</strong> for
<code>NumFinger</code>.Why this can be compiled with no error message?Everything
should have its definition, does it?However, the class-specific constants
that are static and with integral type(<code>int</code>, <code>char</code>, <code>bool</code>,&hellip;) is
an exception.</p>

<p>You can even use the constant.</p>

<pre><code>#include &lt;cstdio&gt;

class Hand {
 public:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};

int main(int argc, char *argv[])
{
    printf("%d\n", Hand::NumFingers);

    return 0;
}
</code></pre>

<p>But when you want to use the address of <code>NumFingers</code>, you must put the
definition of <code>NumFingers</code> in the implemetation file of the class.</p>

<pre><code>#include &lt;cstdio&gt;

class Hand {
 public:
    static const int NumFingers = 5;
    int fingers[NumFingers];
};

const int Hand::NumFingers;

int main(int argc, char *argv[])
{
    printf("%p\n", &amp;Hand::NumFingers);

    return 0;
}
</code></pre>

<p>Remember, there is no need to put <code>static</code> at the begining of the definition.</p>

<p>We know that the size of the array <code>finger</code> is just the value of the static
constant <code>NumFingers</code>.But there is another way to do that.</p>

<pre><code>class Hand {
 public:
    enum {NumFingers = 5};
    int fingers[NumFingers];
};
</code></pre>

<p>That is fine, too.</p>

<h1>For functions</h1>

<p>Macros like this</p>

<pre><code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))
</code></pre>

<p>can result in many painful problems.</p>

<ul>
<li><p>First, you have to remember parenthesizing all the arguments(We all know
why).</p></li>
<li><p>There are problems when calling it like this <code>MAX(++a, b)</code>(It&rsquo;s easy to
think about it).</p></li>
</ul>


<p>If using <code>inline</code> and <code>template</code>, we can solve all this problems.</p>

<pre><code>#include &lt;cstdio&gt;

template&lt;typename T&gt;
inline T
max(const T&amp; a, const T&amp; b)
{
    return a &gt; b ? a : b;
}

int
main(int argc, char *argv[])
{
    char a = 'a', b = 'b';
    int c = 1, d = 2;

    printf("%c\n", max(a, b));
    printf("%d\n", max(c, d));

    return 0;
}
</code></pre>

<p>However, I don&rsquo;t think macros are useless and should be replaced by const,
enum and inline.In a way, macro can decrease the time of compiling and
linking.And there are still lots of code that using macros.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some reviews about C plus plus]]></title>
    <link href="http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus/"/>
    <updated>2013-07-22T19:33:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/07/22/some-reviews-about-c-plus-plus</id>
    <content type="html"><![CDATA[<h1>Declaration and Definition</h1>

<p>I have already known the difference between <strong>declaration</strong> and <strong>definion</strong>,
but now I find that my understanding is not complete.</p>

<p><strong>Declaration</strong> just tells the compiler about the name and the type of
something.It&rsquo;s very common about the declaration of <em>objects</em> and <em>functions</em>.</p>

<pre><code>extern int a;

int max(int a, int b);
</code></pre>

<p>However, I never think about the declaration of <em>class</em>.Recently, I have to
view some codes in a large project and I have found many of these declarations.</p>

<pre><code>class Option;
class Parameter;
</code></pre>

<p>Additionally, there are many declarations of the <em>template class</em>.</p>

<pre><code>template&lt;typename T&gt;
class Swap;
</code></pre>

<p>Another interesting thing is that the official C++ definition of
<em>function signature</em> excludes the return type.I think this is strange and I
will consider it, anyway.</p>

<p><strong>Definition</strong> gives the details of something to the compiler.In the past, I
hold the opinion that <em>definition</em> always be related to <em>memory</em>.In fact, it is
not allways.
&ndash; For object, the definition tell the compiler about the memory asigned for the
object.
&ndash; For function or function template, the definition provides the function body.
&ndash; For class or class template, the definition lists the members of the class.</p>

<p>For example:</p>

<pre><code>int a;

int max(int a, int b)
{
    return a &gt; b ? a : b;
}

class Option {
public:
    Option();
    ~Option();
    ...
};
</code></pre>

<h1>Defaul constructor</h1>

<p>I found I can&rsquo;t tell whether a constructor is a <strong>default constructor</strong> or not.
But now, I know.A <strong>default constructor</strong> is a constructor that can be called
without any arguments.That is, either no parameters or every parameter is
initialized.</p>

<p>The following are default constructors.</p>

<pre><code>Option();
explicit Option(bool short = true);
</code></pre>

<p>And this one is not a default constructor.</p>

<pre><code>explicit Option(bool short);
</code></pre>

<p>What the hell <strong>explicit</strong> is doing here?I have never used this reserved word
even if I have learned C++ for several years.But this guy, <em>explicit</em>, is of
great importance.</p>

<p>Placing <em>explicit</em> before the constructor can prevent the objects of the class
being used to perform implicit type conversions.Obviously, they can be used
for explicit type conversions.</p>

<p>For example, if we have two classes and a function.</p>

<pre><code>class Dog {
    explicit Dog();
    ...
}

Dog aDog;
Cat aCat;

void kill(Dog d);
</code></pre>

<p>Now call the <code>kill</code> function passing <code>aDog</code> as parameter.</p>

<pre><code>kill(aDog);    // No problem.
</code></pre>

<p>If with the <code>explicit</code> reserved word and call the <code>kill</code> function passing
<code>aCat</code> as parameter, it will be error since it prevents implicit type
conversions.</p>

<pre><code>kill(aCat);    // Error, prevent implicit conversion.
</code></pre>

<p>But if without the <code>explicit</code> reserved word and call the <code>kill</code> function
passing <code>aCat</code> as parameter, it will lead the compiler to perform unexpected
type conversions.So the policy is:</p>

<p><strong>Always declare the constructor as explicit.</strong></p>

<h1>Copy constructor and copy assignment operator</h1>

<p>I have already known that this</p>

<pre><code>Parameter p1;
</code></pre>

<p>will invoke the <em>default constructor</em> and this</p>

<pre><code>Parameter p2(p1);
</code></pre>

<p>will invoke the <em>copy constructor</em> and this</p>

<pre><code>p1 = p2;
</code></pre>

<p>will invoke the <em>copy assignment operator</em>, but I have never known that this</p>

<pre><code>Parameter p3 = p2;
</code></pre>

<p>will not invoke the <em>copy assignment operator</em> but the <em>copy constructor</em>.</p>

<p>This amazes me very much.But now I can distinguish it easily.</p>

<p>If a new object is being defined, invoke the <em>copy constructor</em>.Otherwise,
invoke the <em>copy assignment operator</em> since it&rsquo;s just the <strong>asignment</strong>.</p>

<h1>Some common sense</h1>

<ul>
<li>TR1, Technical Report 1, is a specification for new functionality in
C++ standard library.</li>
</ul>


<p>This really deepens my understanding of C plus plus and now I am very
interested in this great programming language.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby-getting started]]></title>
    <link href="http://itlodge.github.io/blog/2013/06/30/ruby-getting-started/"/>
    <updated>2013-06-30T22:54:00+08:00</updated>
    <id>http://itlodge.github.io/blog/2013/06/30/ruby-getting-started</id>
    <content type="html"><![CDATA[<h1>Running ruby</h1>

<h2>Interactive</h2>

<p>In the past, I always tested some ruby statements with <code>irb</code>. Now I can
test a small ruby program in the following way.</p>

<pre><code>[monkey@itlodge octopress]$ ruby
str = "abc"
puts str
Ctrl+d
abc
</code></pre>

<p>After hit <code>ruby</code>, it allows me to type as many code as possible.Finally,
press <code>Ctrl+d</code> will end the input and it will evaluate the code.</p>

<h2>Programs</h2>

<p>When writing a script, we always use <code>#!</code> and specific which language used
to run the code.This is the Unix <a href="http://en.wikipedia.org/wiki/Shebang_%28Unix%29">Shebang</a> notation.For example:</p>

<pre><code>#!/usr/bin/ruby -w
puts "abc"
</code></pre>

<p>From the man page, I know that the <code>-w</code> option means <em>Enables verbose mode
without printing version message at the beginning</em>.</p>

<p>But, many guys like this style:</p>

<pre><code>#!/usr/bin/env ruby
puts "abc"
</code></pre>

<p>From the man page, I know that the <code>env</code> is a program that <em>run a program in
a modified environment</em>.So it can search the <code>$PATH</code> and find the <code>ruby</code>
program to run.</p>

<h1>Ruby documentation</h1>

<p>The site <a href="http://www.ruby-doc.org">ruby-doc.org</a> contains a complete set of the
RDoc documentation for Ruby.</p>

<p>The <code>ri</code> tool is very useful for looking up documentation.If you want to find
the documentation for a class, just type <code>ri ClassName</code>. For example:</p>

<pre><code>[monkey@itlodge ~]$ ri Vector
= Vector &lt; Object

------------------------------------------------------------------------------
= Includes:
Enumerable (from ruby core)

(from ruby core)
------------------------------------------------------------------------------
The Vector class represents a mathematical vector, which is useful in its own
right, and also constitutes a row or column of a Matrix.

== Method Catalogue

To create a Vector:
*   Vector.[](*array)                   
*   Vector.elements(array, copy = true) 

To access elements:
*   [](i)                               

To enumerate the elements:
*  #each2(v)                            
*  #collect2(v)                         
:
</code></pre>

<p>If you want to find the documentation for a method, just type
<code>ri method's name</code>.For example:</p>

<pre><code>[monkey@itlodge ~]$ ri sleep
= .sleep

(from ruby core)
=== Implementation from Kernel
------------------------------------------------------------------------------
  sleep([duration])    -&gt; fixnum


------------------------------------------------------------------------------

Suspends the current thread for duration seconds (which may be
any number, including a Float with fractional seconds). Returns the actual
number of seconds slept (rounded), which may be less than that asked for if
another thread calls Thread#run. Called without an argument, sleep() will
sleep forever.

  Time.new    #=&gt; 2008-03-08 19:56:19 +0900
  sleep 1.2   #=&gt; 1
  Time.new    #=&gt; 2008-03-08 19:56:20 +0900
  sleep 1.9   #=&gt; 2
  Time.new    #=&gt; 2008-03-08 19:56:22 +0900


:
</code></pre>

<p>A method&rsquo;s name may be the same in different classes or modules.In this case,
<code>ri</code> will list all of them.If you type <code>ri ClassName.method's name</code>, it
will show only the documentation of the corresponding class&rsquo;s.</p>

<p>More contributions, more reputations.If a class or module hasn&rsquo;t yet documented
in RDoc, send an email to <code>suggestions@ruby-doc.org</code> to ask them to add.</p>
]]></content>
  </entry>
  
</feed>
